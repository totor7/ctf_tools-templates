#!usr/bin/env python
# coding:utf-8
###############################################################################################
#THIS SCRIPT IS SPECIFICALLY CREATED FOR A DNS_EXFILTRATION CHALLENGE IN WHICH THE EXFILTRATED#
#DATA WAS A PNG IN HEXA AS THE CNAME IN THE DNS RESPONSES ON THE CNAME.DOMAIN. IT SHOULD BE   #
#ADAPTED TO YOUR NEEDS BEFOR USING IT                                                         #
###############################################################################################

import re
from scapy.all import rdpcap, DNSQR, DNSRR

i=0
last = b''

with open("<a.out>", "wb") as f: #  <---- REPLACE HERE a.out by your expected output. Is it an image? text to be deobfuscated? 
    for p in rdpcap('<dns_file.pcap>'): # <---- REPLACE HERE <dns_file.pcap> by the pcap to be analyzed
        if p.haslayer(DNSQR) and not p.haslayer(DNSRR):
            qry = p[DNSQR].qname.decode('utf-8').replace("<domain>","").split(".") #<---- REPLACE HERE <domain> by the domain used in the exchange
            qry = bytes.fromhex(''.join(qry))[9:] # In this specific case we need to pop out the prefix generated by the exfiltration tool (DNSCAT2) : 9 bytes
    
            if last == qry or qry == b'':
                continue
            elif i == 0 : 
                f.write(qry[8:]) # Specific to our case. A flag was set to instantiate the begining of the exfiltrated data. We delete ot.
            else:
                f.write(qry)

            i+=1 # Needed to treat the specific lines (Here line 0). It could has been managed at thend though.
            last=qry # The exfiltrate could volontarely duplicate packets in order to harden the data compilation. Here we skip them thanks to this variable.

return query
